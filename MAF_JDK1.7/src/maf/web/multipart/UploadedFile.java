package maf.web.multipart;

import java.io.File;
import java.io.IOException;

import maf.base.BaseObject;
import maf.util.FileUtils;
import maf.web.exception.UploadedFileException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class UploadedFile extends BaseObject {

    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private String tempFilename = null;	// 임시파일명 (경로 포함)
    private String newFilename = null; // 저장된 파일명(경로 불포함)
    private String newFilePath = null;			// 새로저장된 경로
    private String originalFileName = null;	// 원본 파일
    private String type = null;		// content Type
    private long fileSize = 0;
	final String TMP_FILE_PREFIX = "MI_";
    
//    FileUtil fu = new FileUtil();
    

    public void setUploadedFile( String tempFilename, String original, String type, long filesize) {
        this.tempFilename = tempFilename;
        this.originalFileName = original;
        this.type = type;
        this.fileSize = filesize;
    }
    
    /**
     * mimeType을 돌려줌
     * @return
     */
    public String getContentType() {
      return type;
    }

    /**
     * 경로가 포함된 TempFilenme을 돌려줌 
     * @return
     */
    public String getTmpFilename() {
      return tempFilename;
    }

    /**
     * form에 등록된 파일명
     * @return
     */
    public String getOriginalFileName() {
      return originalFileName;
    }

    /**
     * 임시 파일 오브젝트를 넘겨줌
     * @return
     */
    public File getTempFile() {
        if(tempFilename == null) {
            return null;
        } else {
            return new File(tempFilename);
        }
    }
    
    /**
     * 경로가 포함되지 않은 저장된 파일명을 돌려줌 
     * @return
     */
    public File getNewFile() {
        if(newFilePath != null && newFilename != null) {
            return new File(newFilePath,newFilename);
        } else {
            return null;
        }
    }

    /**
     * 파일이 저장된 경로를 돌려줌
     * 주의!!! fileseprater가 안붙습니다.
     * @return
     */
    public String getNewFilePath() {
        return newFilePath;
    }

    /**
     * 새로저장된 파일명
     * @return
     */
    public String getNewfilename() {
        return newFilename;
    }
    
    /**
     * 파일 크기
     * @return
     */
    public long getFileSize() {
        return fileSize;
    }

    /**
     * 
     * @param filePath 새로저장될 파일 경로 (없으면 생성)
     * @param FileName 저장할 파일명
     * 파일 존재시 기존 파일 덮어씀. 
     * @return
     */
    public boolean SaveAs(String filePath, String FileName)
    throws UploadedFileException{
        return SaveAs(filePath, FileName, true);
    }
    /**
     * 
     * @param filePath : 새로저장될 파일 경로 (없으면 생성)
     * @param canOverwrite : 기존 파일이 있을경우 Overwrite 할것인지? true면 덮어씀.
     * @param fileName 저장할 파일명 
     * @return
     */
    public boolean SaveAs(String filePath, String fileName, boolean canOverwrite)
            throws UploadedFileException {
        File newFile = null;

        if (this.fileSize > 0) {
            try {

            	
                FileUtils.CheckAndMakeDir( filePath );
                //fileName = new String(fileName.getBytes("MS949"),
                // "ISO-8859-1");
                newFile = new File( filePath, fileName );
                if (!canOverwrite) {
                    newFile = rename( newFile );
                }
                
                File TempFile = getTempFile();
                if (TempFile.renameTo( newFile )) {
                    this.newFilename = newFile.getName();
                    System.out.println( newFilename );
                    this.newFilePath = newFile.getParent();
                    return true;
                } else {
                    if (FileUtils.moveFile( TempFile, newFile )) {
                        this.newFilePath = newFile.getParent();
                        this.newFilename = newFile.getName();
                        return true;
                    } else {
                        throw new UploadedFileException( "can' move " + TempFile + "   to "
                                + newFile );
                    }
                }
            } catch (Throwable e) {
                if (newFile != null) {
                    newFile.delete();
                }
            	Log logger = LogFactory.getLog(getClass());
                logger.error( "UploadedFile.SaveAS()  : " + filePath + ", " + fileName + " :"
                        + e.getMessage() );
                throw new UploadedFileException( e.getMessage(), e );
            }
        } else {
            return true;
        }
    }
    
    /**
     * 파일을 FilePath 경로에 Originale 파일명으로 저장
     * MyHttpServletRequest 의 FileSaveTo 권장 
     * @param FilePath : 새로저장될 파일 경로 (없으면 생성)
     * @return
     */
    public boolean SaveTo(String FilePath) throws UploadedFileException{
        return SaveTo(FilePath, false);
    }
    
    /**
     * 파일을 FilePath 경로에 Originale 파일명으로 저장
     * @param FilePath : 새로저장될 파일 경로 (없으면 생성) 
     * @param canOverwrite : 기존 파일이 있을경우 Overwrite 할것인지? 
     * @return
     */
    public boolean SaveTo(String FilePath, boolean canOverwrite)
    throws UploadedFileException{
        // String NewFilePath ;
        // File NewFile = null;
        if(this.originalFileName == null) {
            return false;
        }
        try
        {
       		return SaveAs(FilePath, originalFileName, canOverwrite);
       		
	    }
        catch(Exception e)
        {
            throw new UploadedFileException(e.getMessage(),e);
        }
    }


     
     /**
      *  새로운 파일 생성
      * @param f
      * @return
      */
     private boolean createNewFile(File f) {
         try {
           return f.createNewFile();
         }
         catch (IOException ignored) {
           return false;
         }
       }   
     
     /**
      * 중복된 파일명을 피해 이름 생성
      * @param f
      * @return
      */
     private File rename(File f) {
         if (createNewFile(f)) {
           return f;
         }
         String name = f.getName();
         String body = null;
         String ext = null;

         int dot = name.lastIndexOf(".");
         if (dot != -1) {
           body = name.substring(0, dot) + "_(";
           ext = ")" + name.substring(dot);  // includes "."
         }
         else {
           body = name + "_(";
           ext = ")";
         }

         // Increase the count until an empty spot is found.
         // Max out at 9999 to avoid an infinite loop caused by a persistent
         // IOException, like when the destination dir becomes non-writable.
         // We don't pass the exception up because our job is just to rename,
         // and the caller will hit any IOException in normal processing.
         int count = 0;
         while (!createNewFile(f) && count < 9999) {
           count++;
           String newName = body + count + ext;
           f = new File(f.getParent(), newName);
         }

         return f;
       }
     /**
      * temp 경로에 저장된 임시파일 삭제
      *
      */
     public void deleteFile() {
        try {
            java.io.File f = new java.io.File( tempFilename );
            if (f != null) {
                f.delete();
            }
        } catch (Throwable e) {

        }
    }
     /**
      * 새로이 생성된 파일을 삭제
      *
      */
     public void deleteNewFile() {
        try {
            java.io.File f = new java.io.File( newFilePath + File.separator + this.newFilename );
            if (f != null) {
                f.delete();
            }
        } catch (Throwable e) {

        }

    }
     
     /**
      * Upload 관련 모든 파일 지움 
      * 오류 낳을때 임시, 저장된 파일 지움 
      *
      */
    public void deleteAllFile() {
    	this.deleteFile();
    	this.deleteNewFile();
    }
     	
}
